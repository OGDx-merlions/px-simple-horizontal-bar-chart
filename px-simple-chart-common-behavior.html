<script type="text/javascript" src="bower_components/px/dist/px.min.js"></script>
<script>
/*
    Name:
    pxSimpleChartCommonBehavior

    Description:
    Polymer behavior that provides the basic operations for px-simple-bar-chart,
    px-simple-line-chart, and px-simple-horizontal-bar-chart.
    For example several functions are made available in order to define the
    width and height of the SVG chart drawn using the D3.js graphics library.
    The adds two attributes to an element: `width` and `height` attributes which
    may be defined as: Number, Number as String, or "auto". Numbers will be
    coerced into String and auto will set the element up to be responsive.

    Dependencies:
    - D3.js
    - window.px library

*/

var pxSimpleChartCommonBehavior = {

    defaultWidth: '283',
    defaultHeight: '150',

    properties: {
        /**
        * width
        *
        * Format: String
        */
        width: {
            type: String,
            observer: '_drawChart',
            value: this.defaultWidth
        },
        /**
        * height
        *
        * Format: String
        */
        height: {
            type: String,
            observer: '_drawChart',
            value: this.defaultHeight
        }
    },

    // Fired on attached event
    attached: function() {
        this.svg = this.svg || d3.select(this.$$("svg"));
        this._drawChart();
    },

    /**
     * _drawChart() removes previous chart and debounces multiple calls
    */
    _drawChart: function() {
        this._removeChart();
        // multiple calls to _drawChart need to be debounced
        this.debounce('_drawChartDebounced', function() {
            this._drawChartDebounced();
        }, 310);
    },

    /**
     * _removeChart() removes previous chart and debounces multiple calls
    */
    _removeChart: function() {
        this.debounce('_removeChartDebounced', function() {
            // first ensure that our SVG element is empty
            this._removeChartDebounced();
        }, 300);
    },

    /**
     * _removeChartDebounced() adds the style-scope class of the component to all SVG
     * child nodes. This is necessary because Polymer, while applying the class
     * to child HTML elements, does not apply the class to child SVG elements
     *
    */
    _removeChartDebounced: function() {
        this.svg.attr("width", 1)
            .attr("height", 1)
            .text("");
    },

    /**
     * _addStyleScope() adds the style-scope class of the component to all SVG
     * child nodes. This is necessary because Polymer, while applying the class
     * to child HTML elements, does not apply the class to child SVG elements
     *
    */
    _addStyleScope: function() {
        // polymer doesn't apply style-scope classes to svg child nodes
        // so we need to add .px-simple-bar-chart-svg here
        if(this.svg[0] && this.svg[0][0]) {
            d3.selectAll(this.svg[0][0].childNodes)
                .classed(this.is, true);
        };
    },

    /**
     * _clearSVG() selects the SVG of the chart, shrinks it to 1px by 1px and
     * empties it of child elements. This is necessary to do before drawing or
     * redrawing the chart.
     *
    */
    _clearSVG: function() {
        // select the svg element
        this.svg
            .attr("width", 1)
            .attr("height", 1)
            .text("");
    },

    /**
     * _getSeriesTotal() returns the sum of the values of a series
     *
     * @param {Array} series
     * @return {Number} sum
    */
    _getSeriesTotal: function(series) {
        return series.reduce(function(p,c) {
            return p + c;
        });
    },

    /**
     * _getLongestSeries() returns the longest series
     * based on the array of series passed
     *
     * @param {Array} seriesArray
     * @return {Array} series
    */
    _getLongestSeries: function(seriesArray) {
        try {
            return seriesArray.reduce(function(prev, current) {
                return prev.length < current.length ? current : prev;
            });
        } catch(err) {
            console.log('_getLongestSeries error:', err);
            return 0;
        };
    },

    /**
     * _calculateTextWidth() returns the width in pixels for a given string of
     * text when rendered in SVG using the given className
     *
     * @param {String} text
     * @param {String} className
     * @return {Number} width
    */
    _calculateTextWidth: function(text, className) {
        var textNode = this.svg
            .append("text")
            .attr("class", className)
            .attr("x", 0)
            .attr("y", 0)
            .text(text);
        var width = textNode.node().getComputedTextLength();
        textNode.remove();
         // correct for getComputedTextLength accuracy
        return Math.round(width - (width * 0.21));
    },

    /**
     * _reconcileValue() reconcile the incoming value on an element's attribute
     * This is necessary because some values may come in as one type but
     * need to be interpreted as another type
     *
     * @param {String,Number,Boolean} value
     * @param {String,Number,Boolean} defaultValue
     * @return {String,Number,Boolean} returnValue
    */
    _reconcileValue: function(value, defaultValue) {
        switch(value) {
            case '':
            case false:
            case undefined:
                return defaultValue;
                break;
            case 'false':
                return false;
                break;
            case 'auto':
                return 'auto';
                break;
            default:
                if(px.isFloat(value)) {
                    return parseFloat(value);
                } else if(px.isInt(value)) {
                    return parseInt(value);
                } else {
                    return value;
                };
                break;
        };
    },

    _reconcileWidth: function(value) {
        return this._reconcileDimensionValue(value, this.defaultWidth, 'width');
    },

    _reconcileHeight: function(value) {
        return this._reconcileDimensionValue(value, this.defaultHeight, 'height');
    },

    _reconcileDimensionValue: function(value, defaultValue, type) {
        var value = this._reconcileValue(value, defaultValue);
        return value === 'auto' ? this._getAutoValue(type) : value;
    },

    _getAutoValue: function(type) {
        var parent = this.parentNode;
        var padding = this._getElementPadding(parent);
        if(type === 'width') {
            return parseInt(parent.clientWidth - padding.left - padding.right);
        } else if(type === 'height') {
            return parseInt(parent.clientHeight - padding.top - padding.bottom);
        }
    },

    _getElementPadding: function(el) {
        var style = window.getComputedStyle(el, null);
        return {
            top: style.getPropertyValue('padding-top').split('px')[0],
            right: style.getPropertyValue('padding-right').split('px')[0],
            bottom: style.getPropertyValue('padding-bottom').split('px')[0],
            left: style.getPropertyValue('padding-left').split('px')[0]
        };
    }

};
</script>
