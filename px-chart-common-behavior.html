<script type="text/javascript" src="bower_components/px/dist/px.min.js"></script>
<script>
/*
    Name:
    pxChartCommon

    Description:
    Polymer behavior that provides the basic operations for px-simple-bar-chart
    and px-simple-line-chart

    Dependencies:
    - D3
    - window.px library

*/
var pxChartCommon = {

    // Fired on attached event
    attached: function() {
        this.svg = this.svg || d3.select(this.$$("svg"));
        this._drawChart();
    },

    /**
     * _drawChart() removes previous chart and debounces multiple calls
    */
    _drawChart: function() {
        this._removeChart();
        // multiple calls to _drawChart need to be debounced
        this.debounce('_drawChartDebounced', function() {
            this._drawChartDebounced();
        }, 310);
    },

    /**
     * _removeChart() removes previous chart and debounces multiple calls
    */
    _removeChart: function() {
        this.debounce('_removeChartDebounced', function() {
            // first ensure that our SVG element is empty
            this._removeChartDebounced();
        }, 300);
    },

    /**
     * _removeChartDebounced() adds the style-scope class of the component to all SVG
     * child nodes. This is necessary because Polymer, while applying the class
     * to child HTML elements, does not apply the class to child SVG elements
     *
    */
    _removeChartDebounced: function() {
        this.svg.attr("width", 1)
            .attr("height", 1)
            .text("");
    },

    /**
     * _addStyleScope() adds the style-scope class of the component to all SVG
     * child nodes. This is necessary because Polymer, while applying the class
     * to child HTML elements, does not apply the class to child SVG elements
     *
    */
    _addStyleScope: function() {
        // polymer doesn't apply style-scope classes to svg child nodes
        // so we need to add .px-simple-bar-chart-svg here
        if(this.svg[0] && this.svg[0][0]) {
            d3.selectAll(this.svg[0][0].childNodes)
                .classed(this.is, true);
        };
    },

    /**
     * _clearSVG() selects the SVG of the chart, shrinks it to 1px by 1px and
     * empties it of child elements. This is necessary to do before drawing or
     * redrawing the chart.
     *
    */
    _clearSVG: function() {
        // select the svg element
        this.svg
            .attr("width", 1)
            .attr("height", 1)
            .text("");
    },

    /**
     * _getSeriesTotal() returns the sum of the values of a series
     *
     * @param {Array} series
     * @return {Number} sum
    */
    _getSeriesTotal: function(series) {
        return series.reduce(function(p,c) {
            return p + c;
        });
    },

    /**
     * _getLongestSeries() returns the longest series
     * based on the array of series passed
     *
     * @param {Array} seriesArray
     * @return {Array} series
    */
    _getLongestSeries: function(seriesArray) {
        try {
            return seriesArray.reduce(function(prev, current) {
                return prev.length < current.length ? current : prev;
            });
        } catch(err) {
            console.log('_getLongestSeries error:', err);
            return 0;
        };
    },

    /**
     * _calculateTextWidth() returns the width in pixels for a given string of
     * text when rendered in SVG using the given className
     *
     * @param {String} text
     * @param {String} className
     * @return {Number} width
    */
    _calculateTextWidth: function(text, className) {
        var textNode = this.svg
            .append("text")
            .attr("class", className)
            .attr("x", 0)
            .attr("y", 0)
            .text(text);
        var width = textNode.node().getComputedTextLength();
        textNode.remove();
         // correct for getComputedTextLength accuracy
        return Math.round(width - (width * 0.21));
    },

    /**
     * _reconcileValue() reconcile the incoming value on an element's attribute
     * This is necessary because some values may come in as one type but
     * need to be interpreted as another type
     *
     * @param {String,Number,Boolean} value
     * @param {String,Number,Boolean} defaultValue
     * @return {String,Number,Boolean} returnValue
    */
    _reconcileValue: function(value, defaultValue) {
        switch(value) {
            case '':
            case false:
            case undefined:
                return defaultValue;
                break;
            case 'false':
                return false;
                break;
            case 'auto':
                return 'auto';
                break;
            default:
                if(px.isFloat(value)) {
                    return parseFloat(value);
                } else if(px.isInt(value)) {
                    return parseInt(value);
                } else {
                    return value;
                };
                break;
        };
    }

};
</script>
