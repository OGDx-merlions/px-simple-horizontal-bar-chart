<script>
/*
    Name:
    pxChartCommon

    Description:
    Polymer behavior that provides the basic operations for px-simple-bar-chart
    and px-simple-line-chart

    Depends on D3
*/
var pxChartCommon = {

    // Fired on attached event
    attached: function() {
        this._drawChart();
    },

    _drawChart: function() {
        this._removeChart();
        // multiple calls to _drawChart need to be debounced
        this.debounce('_drawChartDebounced', function() {
            this._drawChartDebounced();
        }, 310);
    },

    _removeChart: function() {
        this.debounce('_removeChartDebounced', function() {
            // first ensure that our SVG element is empty
            this._removeChartDebounced();
        }, 300);
    },

    _removeChartDebounced: function() {
        this.svg = d3.select(this.$$("svg"))
            .attr("width", 1)
            .attr("height", 1);
        // Remove previous child elements
        this.svg.text("");
    },

    _addStyleScope: function() {
        // polymer doesn't apply style-scope classes to svg child nodes
        // so we need to add .px-simple-bar-chart-svg here
        var svg = d3.select(this.$$("svg"));
        if(svg[0] && svg[0][0]) {
            d3.selectAll(svg[0][0].childNodes)
                .classed(this.is, true);
        };
    },


    /**
     * _clearSVG() selects the SVG of the chart, shrinks it to 1px by 1px and
     * empties it of child elements. This is necessary to do before drawing or
     * redrawing the chart.
     *
     * @param {Array} series
     * @return {Number} sum
    */
    _clearSVG: function(svg) {
        // select the svg element
        svg
            .attr("width", 1)
            .attr("height", 1)
            .text("");
    },

    /**
     * _getSeriesTotal() returns the sum of the values of a series
     *
     * @param {Array} series
     * @return {Number} sum
    */
    _getSeriesTotal: function(series) {
        return series.reduce(function(p,c) {
            return p + c;
        });
    },

    /**
     * _getLongestSeries() returns the longest series
     * based on the array of series passed
     *
     * @param {Array} seriesArray
     * @return {Array} series
    */
    _getLongestSeries: function(seriesArray) {
        try {
            return seriesArray.reduce(function(prev, current) {
                return prev.length < current.length ? current : prev;
            });
        } catch(err) {
            console.log('_getLongestSeries error:', err);
            return 0;
        };
    },

    _calculateTextWidth: function(text) {
        var textNode = this.svg
            .append("text")
            .attr("class", "legend-text")
            .attr("x", 0)
            .attr("y", 0)
            .text(text);
        var width = textNode.node().getComputedTextLength();
        textNode.remove();
         // correct for getComputedTextLength accuracy
        return Math.round(width - (width * 0.21));
    },

    _reconcileValue: function(value, defaultValue) {
        switch(value) {
            case '':
            case false:
            case undefined:
                return defaultValue;
                break;
            case 'false':
                return false;
                break;
            case 'auto':
                return 'auto';
                break;
            default:
                if(px.isFloat(value)) {
                    return parseFloat(value);
                } else if(px.isInt(value)) {
                    return parseInt(value);
                } else {
                    return value;
                };
                break;
        };
    }

};
</script>
